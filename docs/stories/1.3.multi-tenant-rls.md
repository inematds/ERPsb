# Story 1.3: Multi-Tenant com Row-Level Security

## Status: Draft

## Story

**As a** usuario com multiplas empresas,
**I want** que meus dados de cada empresa sejam completamente isolados,
**so that** eu possa alternar entre empresas sem risco de vazamento de dados.

## Acceptance Criteria

1. Model Tenant no Prisma com campos: id, name, document (CNPJ/CPF, opcional), type (MEI/ME/informal), plan (free/starter/growth/pro), createdAt
2. Model UserTenant (relacao N:N) com campos: userId, tenantId, role (owner/admin/user)
3. Row-Level Security (RLS) habilitado no PostgreSQL com policies por tenant_id para todas as tabelas de dados
4. Middleware que injeta tenant_id no contexto de cada request com base na sessao do usuario
5. Endpoint para criar novo tenant (empresa)
6. Endpoint para listar tenants do usuario e alternar o tenant ativo
7. Todas as queries Prisma filtradas automaticamente por tenant_id via middleware/extension
8. Teste de isolamento: dados de tenant A nunca acessiveis por tenant B

## Tasks / Subtasks

- [ ] Configurar models Tenant e UserTenant no Prisma (AC: 1, 2)
  - [ ] Adicionar model `Tenant` com campos: id (cuid), name, document, type (default INFORMAL), plan (default FREE), businessType, monthlyRevenue, onboardingCompleted, address (Json), phone, email, logo
  - [ ] Adicionar model `UserTenant` com campos: id, userId, tenantId, role (default OWNER), isActive
  - [ ] Criar relacoes N:N entre User e Tenant via UserTenant
  - [ ] Adicionar constraint `@@unique([userId, tenantId])` no UserTenant
  - [ ] Rodar `prisma db push` para sincronizar schema
- [ ] Implementar Row-Level Security no PostgreSQL (AC: 3)
  - [ ] Criar migration SQL para `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` em todas as tabelas de dados
  - [ ] Criar policy `tenant_isolation` usando `current_setting('app.current_tenant_id', true)`
  - [ ] Aplicar policies em: clientes, fornecedores, produtos, formas_pagamento, contas_pagar, contas_receber, vendas, orcamentos, pix_charges, notas_fiscais, config_fiscal, movimentacoes_estoque, whatsapp_messages, audit_logs, reminder_configs
  - [ ] Testar RLS via SQL direto no Supabase
- [ ] Criar Prisma Client Extension para tenant auto-injection (AC: 7)
  - [ ] Atualizar `src/lib/prisma.ts` com `$extends()` que intercepta todas as operacoes
  - [ ] Skip models sem tenantId (User, UserTenant)
  - [ ] Injetar `tenantId` automaticamente em `where` clauses (findMany, findFirst, update, delete)
  - [ ] Injetar `tenantId` automaticamente em `data` de `create`
  - [ ] Validar que `tenantId` nunca e undefined/null antes de queries
- [ ] Implementar tenant middleware/context (AC: 4)
  - [ ] Criar `src/core/tenant/tenant.middleware.ts` que extrai tenantId da sessao JWT
  - [ ] Criar `src/core/tenant/tenant.context.ts` com AsyncLocalStorage para propagar tenantId
  - [ ] Integrar com NextAuth session callback para incluir activeTenantId no token JWT
  - [ ] Criar funcao `getTenantIdFromContext()` usada pelo Prisma extension
  - [ ] Configurar `SET app.current_tenant_id` no Prisma `$executeRaw` antes de queries RLS
- [ ] Criar tenant service e endpoints (AC: 5, 6)
  - [ ] Criar `src/core/tenant/tenant.service.ts` com: createTenant, listUserTenants, switchActiveTenant
  - [ ] Criar `src/app/api/v1/tenants/route.ts` - POST (criar) e GET (listar do usuario)
  - [ ] Implementar logica de `switchActiveTenant`: atualizar UserTenant.isActive (desativar anterior, ativar novo)
  - [ ] Validar que usuario pertence ao tenant antes de switch
  - [ ] Ao criar tenant: criar UserTenant com role OWNER e isActive=true automaticamente
- [ ] Criar hook `useTenant` para client-side (AC: 6)
  - [ ] `src/hooks/use-tenant.ts` - hook React para acessar tenant ativo
  - [ ] Expor: activeTenantId, activeTenantName, switchTenant(), tenantList
  - [ ] Sincronizar com sessao do NextAuth
- [ ] Implementar testes de isolamento (AC: 8)
  - [ ] Teste unitario: Prisma extension injeta tenantId corretamente
  - [ ] Teste integracao: criar dados no tenant A e verificar que nao aparecem em query do tenant B
  - [ ] Teste integracao: tentativa de acessar recurso de outro tenant retorna 403/vazio
  - [ ] Teste unitario: getTenantIdFromContext() retorna tenantId correto

## Dev Notes

**Source Tree relevante:**
```
src/
├── core/tenant/
│   ├── tenant.service.ts      # Tenant CRUD + switch
│   ├── tenant.context.ts      # AsyncLocalStorage para tenant context
│   ├── tenant.middleware.ts   # Extrai tenantId da sessao
│   └── plan-limits.ts         # Plan feature limits (placeholder)
├── hooks/
│   └── use-tenant.ts          # Client-side tenant hook
├── lib/
│   └── prisma.ts              # Prisma singleton + tenant extension
├── app/api/v1/tenants/
│   └── route.ts               # POST/GET tenants
└── types/
    └── next-auth.d.ts         # Type augmentation (activeTenantId)
```

**Depende de:** Story 1.1 (Prisma setup, User model) e Story 1.2 (NextAuth session/JWT)

**Prisma Client Extension pattern:**
```typescript
// src/lib/prisma.ts
import { AsyncLocalStorage } from 'async_hooks';

const tenantContext = new AsyncLocalStorage<{ tenantId: string }>();

export function getTenantIdFromContext(): string | undefined {
  return tenantContext.getStore()?.tenantId;
}

const prismaWithTenant = prisma.$extends({
  query: {
    $allModels: {
      async $allOperations({ args, query, model }) {
        if (['User', 'UserTenant'].includes(model)) return query(args);
        const tenantId = getTenantIdFromContext();
        if (!tenantId) throw new Error('Tenant context required');
        // Inject in where and create data...
        return query(args);
      },
    },
  },
});
```

**RLS Policy SQL pattern:**
```sql
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_isolation ON clientes
  USING (tenant_id = current_setting('app.current_tenant_id', true));
```

**Env vars necessarias:** Nenhuma adicional (usa DATABASE_URL existente)

**Coding Standards:**
- Tenant context via AsyncLocalStorage (Node.js API) - nao usar no Edge Runtime
- Middleware de tenant roda APOS middleware de auth (encadeamento)
- Nunca fazer query sem tenant context (exceto User e UserTenant)
- Validar tenantId com Zod antes de operacoes criticas

### Testing

- **Localizacao:** `tests/unit/core/tenant/` e `tests/integration/api/tenants/`
- **Framework:** Vitest
- **Testes necessarios:**
  - Prisma extension injeta tenantId em create automaticamente
  - Prisma extension injeta tenantId em where automaticamente
  - `getTenantIdFromContext()` retorna undefined fora de contexto
  - `getTenantIdFromContext()` retorna tenantId dentro de contexto
  - `createTenant()` cria Tenant + UserTenant com role OWNER
  - `switchActiveTenant()` alterna isActive corretamente
  - Isolamento: dados de tenant A nao visíveis para tenant B
  - API POST /tenants cria tenant e retorna 201
  - API GET /tenants retorna apenas tenants do usuario logado
- **E2E (futuro):** Alternar entre empresas e verificar dados isolados

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-07 | 1.0 | Criacao inicial da story | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
*A ser preenchido pelo dev agent*

### Debug Log References
*A ser preenchido pelo dev agent*

### Completion Notes List
*A ser preenchido pelo dev agent*

### File List
*A ser preenchido pelo dev agent*

## QA Results
*A ser preenchido pelo QA agent*
